
#pragma once

#include <vector>

#include <boost/noncopyable.hpp>
#include <boost/ptr_container/ptr_vector.hpp>

#include "Artus/Core/interface/FilterBase.h"
#include "Artus/Core/interface/ProductBase.h"
#include "Artus/Core/interface/FilterResult.h"
#include "Artus/Core/interface/EventBase.h"
#include "Artus/Core/interface/MetadataBase.h"
#include "Artus/Core/interface/ProcessNodeBase.h"
#include "Artus/Configuration/interface/SettingsBase.h"


class ConsumerBaseAccess;


/*
 The base class to implement your own Consumer which run within an Pipeline.
 This class gets the FilterResult, the created products, the settings and the input event ifself
 and can create the output you desire.
 It is not allowed to write to the settings, filter, event and products.
 */

class ConsumerBaseUntemplated : public ProcessNodeBase
{
public:

	// this will allow the pipeline class to call the protected
	// base implemenations of ProcessEvent / Init and friends
	friend ConsumerBaseAccess;

	virtual ~ConsumerBaseUntemplated();

	/*
	 * Must return a unique id of the Consumer.
	 */
	virtual std::string GetConsumerId() const = 0;

protected:
	// will be implemented by the ConsumerBase class
	virtual void baseInit(SettingsBase const& settings, MetadataBase& metadata) = 0;
	
	virtual void baseOnRun(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata) = 0;
	virtual void baseOnLumi(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata) = 0;
	
	virtual void baseProcess(SettingsBase const& settings, MetadataBase const& metadata) = 0;
	virtual void baseProcessEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata, FilterResult& fres) = 0;
	virtual void baseProcessFilteredEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata) = 0;
	
	virtual void baseFinish(SettingsBase const& settings, MetadataBase const& metadata) = 0;
};

class ConsumerBaseAccess
{
public:
	explicit ConsumerBaseAccess(ConsumerBaseUntemplated& consumer);

	void Init(SettingsBase const& settings, MetadataBase& metadata);
	
	void OnLumi(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata);
	void OnRun(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata);
	
	void Process(SettingsBase const& settings, MetadataBase const& metadata);
	void ProcessEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata, FilterResult fres);
	void ProcessFilteredEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata);
	
	void Finish(SettingsBase const& settings, MetadataBase const& metadata);

private:
	ConsumerBaseUntemplated& m_consumer;
};


template<class TTypes>
class ConsumerBase: public ConsumerBaseUntemplated
{
public:

	typedef typename TTypes::event_type event_type;
	typedef typename TTypes::product_type product_type;
	typedef typename TTypes::setting_type setting_type;
	typedef typename TTypes::metadata_type metadata_type;

	virtual ~ConsumerBase()
	{
	}

	virtual void Init(setting_type const& settings, metadata_type& metadata)
	{
		LOG(DEBUG) << "Initialize consumer \"" << this->GetConsumerId() << "\".";
	}

	virtual void OnRun(event_type const& event, setting_type const& settings, metadata_type const& metadata)
	{
	}
	
	virtual void OnLumi(event_type const& event, setting_type const& settings, metadata_type const& metadata)
	{
	}

	/*
	 *  this method is called for pipeline which do not operate on event input but on data
	 *  generated by preceeding pipelines
	 */
	virtual void Process(setting_type const& settings, metadata_type const& metadata)
	{
	}

	/* this method is only called for events which have passed the filter imposed on the
	 * pipeline
	 */
	virtual void ProcessFilteredEvent(event_type const& event, product_type const& product, setting_type const& settings, metadata_type const& metadata)
	{
	}

	/*
	 *  this method is called for all events
	 *  Depending on the outcome of the pipeline (a filter might have stopped the producers
	 *  prematurely), some local products might not have been filled
	 */

	//add setting_type const& globalSettings here !!
	virtual void ProcessEvent(event_type const& event, product_type const& product, setting_type const& settings, metadata_type const& metadata, FilterResult& result)
	{
	}

	/*
	 * Called after the last event. Overwrite this to store your histograms etc. to disk
	 */
	virtual void Finish(setting_type const& settings, metadata_type const& metadata) = 0;

	/*
	 * Return a reference to the settings used for this consumer
	 */
	/*setting_type const& GetPipelineSettings() const
	{
		return this->m_pipeline->GetSettings();
	}*/

	ProcessNodeType GetProcessNodeType() const final
	{
		return ProcessNodeType::Consumer;
	}

protected:

	void baseInit(SettingsBase const& settings, MetadataBase& metadata) override
	{
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type& specMetadata = static_cast<metadata_type&>(metadata);

		this->Init(specSettings, specMetadata);
	}

	void baseOnLumi(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata) override
	{
		event_type const& specEvent = static_cast<event_type const&>(evt);
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		this->OnLumi(specEvent, specSettings, specMetadata);
	}

	void baseOnRun(EventBase const& evt, SettingsBase const& settings, MetadataBase const& metadata) override
	{
		event_type const& specEvent = static_cast<event_type const&>(evt);
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		this->OnRun(specEvent, specSettings, specMetadata);
	}

	void baseProcess(SettingsBase const& settings, MetadataBase const& metadata) override
	{
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		Process(specSettings, specMetadata);
	}

	void baseProcessEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata, FilterResult& fres)	override
	{
		event_type const& specEvent = static_cast<event_type const&>(evt);
		product_type const& specProduct = static_cast<product_type const&>(prod);
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		ProcessEvent(specEvent, specProduct, specSettings, specMetadata, fres);
	}

	void baseProcessFilteredEvent(EventBase const& evt, ProductBase const& prod, SettingsBase const& settings, MetadataBase const& metadata) override
	{
		event_type const& specEvent = static_cast<event_type const&>(evt);
		product_type const& specProduct = static_cast<product_type const&>(prod);
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		ProcessFilteredEvent(specEvent, specProduct, specSettings, specMetadata);
	}

	void baseFinish(SettingsBase const& settings, MetadataBase const& metadata) override
	{
		setting_type const& specSettings = static_cast<setting_type const&>(settings);
		metadata_type const& specMetadata = static_cast<metadata_type const&>(metadata);

		this->Finish(specSettings, specMetadata);
	}
};
